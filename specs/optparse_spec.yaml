before:
  require "specl.shell"

specify optparse:
- before: |
    OptionParser = require "specl.optparse"

    help = [[
    parseme (specl check) 0α1

    Copyright © 2013 Gary V. Vaughan
    This test program comes with ABSOLUTELY NO WARRANTY.

    Usage: parseme [<options>] <file>...

    Banner text.

    Long description.

    Options:

      -h, --help           display this help, then exit
          --version        display version information, then exit
      -v, --verbose        be verbose
      -o, --output=[FILE]  parse an optional argument
      -n, --name=USER      require an argument
      -b                   a boolean with no long option

    Footer text.

    Please report bugs at <http://github.com/gvvaughan/specl/issues>.
    ]]

    -- strip off the leading whitespace required for YAML
    parser = OptionParser (help:gsub ("^    ", ""))

- describe OptionParser:
  - it recognises the program name:
      expect (parser.program).should_be "parseme"
  - it recognises the version number:
      expect (parser.version).should_be "0α1"
  - it recognises the version text:
      expect (parser.versiontext).
        should_match "^parseme .*Copyright .*NO WARRANTY%."
  - it recognises the help text: |
      expect (parser.helptext).
        should_match "^Usage: parseme .*Banner .*Long .*Options:.*Footer .*/issues>%."
  - it diagnoses incorrect input text:
      expect (OptionParser "garbage in").should_error "argument must match"

- describe parser:
  - before: |
      f = os.tmpname ()

      function parse (arglist)
        local d = f:gsub ("/[^/]*$", "", 1)
        local h = io.open (f, "w")

        h:write ([[
          package.path = "]] .. package.path .. [["
          OptionParser = require 'specl.optparse'
          help = [=[]] .. help .. [[]=]
          help = help:match ("^[%s\n]*(.-)[%s\n]*$")

          parser = OptionParser (help)
          _G.arg, opts = parser:parse (_G.arg)

          o = {}
          for k, v in pairs (opts) do table.insert (o, k .. " = " .. tostring (v)) end
          o[1] = "opts = { " .. o[1]
          o[#o] = o[#o] .. " }"

          print (table.concat (o, ", "))
        ]])
        h:close ()

        return spawn {arg[-1], f, unpack (arglist)}
      end
  - after: os.remove (f)

  - "it responds to --version with version text": |
      expect (parse {"--version"}).
        should_match_output "^%s*parseme .*Copyright .*NO WARRANTY%.\n$"
  - "it responds to --help with help text": |
      expect (parse {"--help"}).
        should_match_output "^%s*Usage: parseme .*Banner.*Long.*Options:.*Footer.*/issues>%.\n$"
  - it responds to --verbose:
      expect (parse {"--verbose"}).should_output "opts = { verbose = true }\n"
