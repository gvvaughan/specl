before: |
  hell = require "specl.shell"
  Command, spawn = hell.Command, hell.spawn

  preamble = "before:\n" ..
             "  hell = require 'specl.shell'\n" ..
             "  Command, spawn = hell.Command, hell.spawn\n" ..
             "it fails:\n" ..
             "  expect "
  fail_1   = "\n0 passed, 0 pending, and 1 failed"

# For speed, run most of the expectations in specl's process.  Forking
# another Lua to restart an out-of-process specl, and having it load a
# and report on a test specification file is an order of magnitude
# slower (maybe two orders!).

describe shell:
- describe Command instance:
  - it diagnoses incompatible arguments:
      expect (Command ()).to_error "string or table expected, got no value"
      expect (Command (function () end)).
        to_error "string or table expected, got function"

  - it is a command factory:
      expect (Command "echo").to_instantiate_a "Command"
      expect (Command {"echo"}).to_instantiate_a "Command"


- describe spawn:
  - it diagnoses incompatible arguments:
      expect (spawn ()).to_error "string, table or Command expected"

  - it is a process factory:
      expect (spawn (Command "echo")).to_instantiate_a "Process"
      expect (spawn {"echo"}).to_instantiate_a "Process"
      expect (spawn "echo").to_instantiate_a "Process"


- describe exit matcher:
  # There's also a few ugly, but considerably faster than a full fork,
  # cases where we can tickle a Lua error in-process, and wrap it in a
  # `to_error` to check the behaviour of an expectation or matcher.
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_exit (0)).to_error "Process expected"

  # The other exceptions are where we want to test that an expectation
  # fails correctly, which involves using the shell extensions to fork
  # a whole other specl process, where we then compare it's output with
  # what we'd expect from the failure we're tickling.
  - it displays actual and expected output on failure:
      yaml = preamble .. "(spawn 'exit 3').to_exit (7)"
      expect (run_spec (yaml)).
        to_contain_output "expecting exit status 7, but got 3"
  - it displays all expected and actual output for all_of failures:
      yaml = preamble .. "(spawn 'exit 3').to_exit.all_of {1, 2, 3}"
      expect (run_spec (yaml)).
        to_contain_output "expecting an exit status of 1, 2 and 3, but got 3"
  - it displays all expected and actual output for any_of failures:
      yaml = preamble .. "(spawn 'exit 3').to_exit.any_of {7, 11}"
      expect (run_spec (yaml)).
        to_contain_output "expecting an exit status of 7 or 11, but got 3"

  - context when called normally:
    - it succeeds when process exit status matches:
        expect (spawn "exit 0").to_exit (0)
    - it fails when process exit status is unexpected:
        yaml = preamble .. "(spawn 'exit 3').to_exit (7)"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when proces exit status is unexpected:
        expect (spawn "exit 3").not_to_exit (7)
    - it fails when process exit status matches:
        yaml = preamble .. "(spawn 'exit 0').not_to_exit (0)"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe output matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_output "meh").to_error "Process expected"
  - it displays actual and expected output on failure: |
      yaml = preamble .. "(spawn 'printf hello').to_output 'hell'"
      expect (run_spec (yaml)).
        to_match_output ("expecting output:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_output.all_of {'heaven', 'hell'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output:\n" ..
                         "%s*| heaven\n" ..
                         "%s*and:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_output.any_of {'heaven', 'hell'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output:\n" ..
                         "%s*| heaven\n" ..
                         "%s*or:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the output matches exactly:
        expect (spawn "printf hello").to_output "hello"
    - it fails when the output mismatches:
        yaml = preamble .. "(spawn 'printf hello').to_output 'hell'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the output mismatches:
        expect (spawn "printf hello").not_to_output "hell"
    - it fails when the output matches:
        yaml = preamble .. "(spawn 'printf hello').not_to_output 'hello'"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe output_error matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_output_error "meh").to_error "Process expected"
  - it displays actual and expected output on failure: |
      yaml = preamble .. "(spawn 'printf hello >&2').to_output_error 'hell'"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_output_error.all_of {'heaven', 'hell'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output:\n" ..
                         "%s*| heaven\n" ..
                         "%s*and:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_output_error.any_of {'heaven', 'hell'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output:\n" ..
                         "%s*| heaven\n" ..
                         "%s*or:\n" ..
                         "%s*| hell\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the error output matches exactly:
        expect (spawn "printf hello >&2").to_output_error "hello"
    - it fails when the error output mismatches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').to_output_error 'hell'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the output mismatches:
        expect (spawn "printf hello >&2").not_to_output "hell"
    - it fails when the output matches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').not_to_output_error 'hello'"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe match_output matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_match_output "meh").to_error "Process expected"
  - it displays actual and expected output on failure:
      yaml = preamble .. "(spawn 'printf hello').to_match_output '%s+'"
      expect (run_spec (yaml)).
        to_match_output ("expecting output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_match_output.all_of {'%s+', '%d+'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*and:\n" ..
                         "%s*| %%d%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_match_output.any_of {'%s+', '%d+'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*or:\n" ..
                         "%s*| %%d%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the output matches:
        expect (spawn "printf hello").to_match_output "%S+"
    - it fails when the output mismatches:
        yaml = preamble .. "(spawn 'printf hello').to_match_output '%s+'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the output mismatches:
        expect (spawn "printf hello").not_to_match_output "%s+"
    - it fails when the output matches:
        yaml = preamble .. "(spawn 'printf hello').not_to_match_output '%S+'"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe match_error matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_match_error "meh").to_error "Process expected"
  - it displays actual and expected output on failure: |
      yaml = preamble .. "(spawn 'printf hello >&2').to_match_error '%s+'"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_match_error.all_of {'%s+', '%d+'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*and:\n" ..
                         "%s*| %%d%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_match_error.any_of {'%s+', '%d+'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output matching:\n" ..
                         "%s*| %%s%+\n" ..
                         "%s*or:\n" ..
                         "%s*| %%d%+\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the error output matches:
        expect (spawn "printf hello >&2").to_match_error "%S+"
    - it fails when the error output mismatches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').to_match_error '%s+'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the error output mismatches:
        expect (spawn "printf hello >&2").not_to_match_error "%s+"
    - it fails when the error output matches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').not_to_match_error '%S+'"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe contain_output matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("meh").to_contain_output "meh").to_error "Process expected"
  - it displays actual and expected output on failure: |
      yaml = preamble .. "(spawn 'printf hello').to_contain_output '~'"
      expect (run_spec (yaml)).
        to_match_output ("expecting output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_contain_output.all_of {'~', 'x', 'foo'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*and:\n" ..
                         "%s*| x\n" ..
                         "%s*and:\n" ..
                         "%s*| foo\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello').to_contain_output.any_of {'~', 'x', 'foo'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*or:\n" ..
                         "%s*| x\n" ..
                         "%s*or:\n" ..
                         "%s*| foo\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the output contains the match text:
        expect (spawn "printf hello").to_contain_output "e"
    - it fails when the output does not contain the match text:
        yaml = preamble .. "(spawn 'printf hello').to_contain_output '~'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the output does not contain the match text:
        expect (spawn "printf hello").not_to_contain_output "~"
    - it fails when the output contains the match text:
        yaml = preamble .. "(spawn 'printf hello').not_to_contain_output 'e'"
        expect (run_spec (yaml)).to_contain_output (fail_1)


- describe contain_error matcher:
  - it diagnoses incompatible arguments:
      expect (expect ("eh").to_contain_error "eh").to_error "Process expected"
  - it displays actual and expected output on failure: |
      yaml = preamble .. "(spawn 'printf hello >&2').to_contain_error '~'"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for all_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_contain_error.all_of {'~', 'x', 'foo'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*and:\n" ..
                         "%s*| x\n" ..
                         "%s*and:\n" ..
                         "%s*| foo\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")
  - it displays all expected and actual output for any_of failures:
      yaml = preamble ..
             "(spawn 'printf hello >&2').to_contain_error.any_of {'~', 'x', 'foo'}"
      expect (run_spec (yaml)).
        to_match_output ("expecting error output containing:\n" ..
                         "%s*| ~\n" ..
                         "%s*or:\n" ..
                         "%s*| x\n" ..
                         "%s*or:\n" ..
                         "%s*| foo\n" ..
                         "%s*but got:\n" ..
                         "%s*| hello\n")

  - context when called normally:
    - it succeeds when the error output contains the match text:
        expect (spawn "printf hello >&2").to_contain_error "e"
    - it fails when the output mismatches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').to_contain_error '~'"
        expect (run_spec (yaml)).to_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds when the output mismatches:
        expect (spawn "printf hello >&2").not_to_contain_error "~"
    - it fails when the output matches:
        yaml = preamble ..
               "(spawn 'printf hello >&2').not_to_contain_error 'e'"
        expect (run_spec (yaml)).to_contain_output (fail_1)
