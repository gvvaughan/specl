before: |
  require "specl.shell"
  require "spec_helper"

  preamble = "before: hell = require 'specl.shell'\nit fails: expect "
  fail_1   = "\n0 passed, 0 pending, and 1 failed"
  pass_all = "\nAll expectations met"

describe matcher:
- before:
    deep = "({{ 'subtable 1', {'sub-subtable'} }, { 'subtable 2' }})"

- it diagnoses zero alternatives with all_of:
    expect (expect (1).should_be.all_of {}).
      should_error "non-empty table expected"
- it diagnoses zero alternatives with any_of:
    expect (expect (1).should_be.any_of {}).
      should_error "non-empty table expected"
- it diagnoses unsupported matcher adaptors:
    expect (expect (1).should_not_be.the_thing_that ()).
      should_error "unknown 'the_thing_that' adaptor with 'should_not_be'"

- describe be:
  - it displays expected and actual output for failures:
      yaml = preamble .. "(1).should_be 'one'"
      expect (run_spec (yaml)).
        should_contain_output 'expecting exactly "one", but got 1'
  - it displays all expected and actual output for all_of failures:
      yaml = preamble .. "(3).should_be.all_of {'five', 2, 1}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting all of "five", 2 and 1, but got 3'
  - it displays all expected and actual output for any_of failures:
      yaml = preamble .. "(3).should_be.any_of {'five', 2, 1}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting any of "five", 2 or 1, but got 3'
  - it displays the normal format where all_of has only one alternative:
      yaml = preamble .. "(3).should_be.all_of {'five'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting exactly "five", but got 3'
  - it displays the normal format where any_of has only one alternative:
      yaml = preamble .. "(3).should_be.any_of {'five'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting exactly "five", but got 3'

  - context when called normally:
    - it succeeds when comparing identical objects:
        expect (1).should_be (1)
    - it succeeds when object is any of the alternatives:
        expect (2).should_be.any_of {5, 2, 1}
    - it succeeds when object is all of the alternatives:
        expect (3).should_be.all_of {1 + 2, 3, 4 - 1}
    - it fails when comparing different objects:
        yaml = preamble .. "(1).should_be 'one'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is not any of the alternatives:
        yaml = preamble .. "(3).should_be.any_of {5, 2, 1}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is not all of the alternatives:
        yaml = preamble .. "(3).should_be.all_of {1 + 2, 3, 4}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds when comparing different objects:
        expect (1).should_not_be 'one'
    - it succeeds when object is not any of the alternatives:
        expect (3).should_not_be.any_of {5, 2, 1}
    - it succeeds when object is not all of the alternatives:
        expect (3).should_not_be.all_of {5, 2, 1}
    - it fails when comparing identical objects:
        yaml = preamble .. "(1).should_not_be (1)"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is any of the alternatives:
        yaml = preamble .. "(2).should_not_be.any_of {5, 2, 1}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is all of the alternatives:
        yaml = preamble .. "(3).should_not_be.all_of {1 + 2, 3, 4 + 5 - 6}"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe equal:
  - it displays expected and actual output for failures:
      yaml = preamble .. "('str').should_equal {'table'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting {1=table}, but got "str"'
  - it displays all expected and actual output for all_of failures:
      yaml = preamble .. "('str').should_equal.all_of {'table', 'number'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting all of "table" and "number", but got "str"'
  - it displays all expected and actual output for any_of failures:
      yaml = preamble .. "('str').should_equal.any_of {'table', 'number'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting any of "table" or "number", but got "str"'
  - context when called normally:
    - it succeeds when comparing equal objects:
        expect ({}).should_equal {}
    - it makes a deep comparison of table elements:
        yaml = preamble .. deep .. ".should_equal " .. deep
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when object equals all of the alternatives:
        yaml = preamble .. deep ..
               ".should_equal.all_of {" .. deep .. ", " .. deep .. "}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when object equals any of the alternatives:
        yaml = preamble .. deep .. ".should_equal.any_of {0, {0}, " .. deep .. "}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended objects have equal contents:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_equal (hell.Process {1, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended object equals all of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_equal." ..
               "all_of {hell.Process {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended object equals any of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_equal." ..
               "any_of {1, 'good', 'bad', {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it fails when comparing unequal objects:
        yaml = preamble .. "('str').should_equal {'table'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object does not equal all of the alternatives:
        yaml = preamble .. "('str').should_equal.all_of {'str', 'table'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object does not equal any of the alternatives:
        yaml = preamble .. "('str').should_equal.any_of {0, {0}, 'table'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended objects have unequal types:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_equal (hell.Command {1, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended objects have unequal contents:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_equal (hell.Process {2, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended object does not equal all of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_equal." ..
               "all_of {hell.Process {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}, 'another thing'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended object does not equal any of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_equal." ..
               "any_of {1, 'good', 'bad', {1, 'good', 'bad'}, " ..
               "hell.Process {2, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds when comparing unequal objects:
        expect ('str').should_not_equal {'table'}
    - it succeeds when object does not equal all of the alternatives:
        expect ('str').should_not_equal.all_of {'str', 'table'}
    - it succeeds when object is not any of the alternatives:
        expect ('str').should_not_equal.any_of {0, {0}, 'table'}
    - it succeeds when extended objects have unequal types:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_not_equal (hell.Command {1, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended objects have unequal contents:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_not_equal (hell.Process {2, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended object does not equal all of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_not_equal." ..
               "all_of {hell.Process {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}, 'another thing'}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds when extended object does not equal any of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_not_equal." ..
               "any_of {1, 'good', 'bad', {1, 'good', 'bad'}, " ..
               "hell.Process {2, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it fails when comparing equal objects:
        yaml = preamble .. "({1, {2}}).should_not_equal {1, {2}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object equals all of the alternatives:
        yaml = preamble .. "({1, {2}}).should_not_equal.all_of {{1, {2}}, {1, {2}}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object does not equal any of the alternatives:
        yaml = preamble .. "({1, {2}}).should_not_equal.any_of {{1, {2}}, 3, {4}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended objects have equal contents:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'})." ..
               "should_not_equal (hell.Process {1, 'good', 'bad'})"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended object equals all of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_not_equal." ..
               "all_of {hell.Process {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when extended object equals any of the alternatives:
        yaml = preamble .. "(hell.Process {1, 'good', 'bad'}).should_not_equal." ..
               "any_of {1, 'good', 'bad', {1, 'good', 'bad'}, " ..
               "hell.Process {1, 'good', 'bad'}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe contain:
  - it diagnoses incompatible arguments:
      expect (expect (function () end).should_contain "nothing").
        should_error "string, table or object expected"
  - context with a_permutation_of adaptor:
    - it diagnoses incompatible arguments to expect:
        expect (expect (function () end).should_contain.a_permutation_of ("nothing")).
          should_error "string, table or object expected"
    - it diagnoses incompatible arguments to adaptor:
        expect (expect ("nothing").should_contain.a_permutation_of (function () end)).
          should_error "string or table expected"

  - context when receiving a string:
    - it displays expected and actual output for failures:
        yaml = preamble .. "('tilde').should_contain '~'"
        expect (run_spec (yaml)).
          should_contain_output 'expecting string containing "~", but got "tilde"'
    - it displays expected and actual output for a_permutation_of failures:
        yaml = preamble .. "('tilde').should_contain.a_permutation_of ('elite')"
        expect (run_spec (yaml)).
          should_contain_output ('expecting string containing a permutation of ' ..
                                 '"elite", but got "tilde"')
    - it displays all expected and actual output for all_of failures:
        yaml = preamble .. "('tilde').should_contain.all_of {'t', 'i', 'de', '~'}"
        expect (run_spec (yaml)).
          should_contain_output ('expecting string containing all of "t",' ..
                                 ' "i", "de" and "~", but got "tilde"')
    - it displays all expected and actual output for any_of failures:
        yaml = preamble .. "('tilde').should_contain.any_of {'~', 'x', 'foo', 9}"
        expect (run_spec (yaml)).
          should_contain_output ('expecting string containing any of "~",' ..
                                 ' "x", "foo" or 9, but got "tilde"')
    - context while called normally:
      - it succeeds if the substring is present:
          expect ("English Language").should_contain "e"
      - it succeeds if a permutation of the listed string is present:
          expect ("english language").
           should_contain.a_permutation_of "ungenial haggles"
      - it succeeds if all of the listed substrings are present:
          expect ("English Language").
           should_contain.all_of {"English", "Language", "ngu"}
      - it succeeds if any of the listed substrings is present:
          expect ("English Language").
           should_contain.any_of {"Cornish", "English", "Gaelic"}
      - it fails if the substring is absent:
          yaml = preamble .. "('English Language').should_contain '~'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if a permutation of the listed string is absent:
          yaml = preamble .. "('english language').should_contain." ..
                 "a_permutation_of 'engaged languish'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails of any of the listed substrings is absent:
          yaml = preamble .. "('English Language').should_contain." ..
                 "all_of {'ngl', 'ngu', 'ngz'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails of none of the listed substrings is present:
          yaml = preamble .. "('English Language').should_contain." ..
                 "any_of {'Celtic', 'Cornish', 'Gaelic'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
    - context while called with not_ prefix:
      - it succeeds if the substring is absent:
          expect ("English Language").should_not_contain "~"
      - it succeeds if a permutation of the listed string is absent:
          expect ("english language").should_not_contain.
            a_permutation_of "engaged languish"
      - it succeeds if none of the listed substrings is present:
          expect ("English Language").should_not_contain.
            all_of {"Celtic", "Cornish", "Gaelic"}
      - it succeeds if none of the listed substrings is present:
          expect ("English Language").should_not_contain.
            any_of {"Celtic", "Cornish", "Gaelic"}
      - it fails if the substring is present:
          yaml = preamble .. "('English Language').should_not_contain 'e'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if a permutation of the listed string is present:
          yaml = preamble .. "('english language').should_not_contain."..
                 "a_permutation_of 'ungenial haggles'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if all of the listed substrings are present:
          yaml = preamble .. "('English Language').should_not_contain." ..
                 "all_of {'English', 'Language', 'ish'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if any of the listed substrings is present:
          yaml = preamble .. "('English Language').should_not_contain." ..
                 "any_of {'British', 'English', 'Language'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)

  - context when receiving a table:
    - before:
        vals = "({ 'one', 'two', 'five' })"
        keys = "({ one = true, two = true, five = true })"

    # This is probably too specific and brittle... but I do want to make
    # sure the pretty printing of tables doesn't break with future
    # releases, so let's try and see whether it flies.
    - it displays expected and actual output for failures: |
        yaml = preamble .. "({'one', 'two', 'five'}).should_contain 'three'"
        expect (run_spec (yaml)).
          should_match_output ("expecting table containing \"three\", but got:\n" ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*|%s*%[3%] = \"five\",\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for a_permutation_of failures:
        yaml = preamble .. "({'one', 'two'}).should_contain.a_permutation_of {'three', 'four'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting table containing a permutation of "three" and "four", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for all_of failures:
        yaml = preamble .. "({'one', 'two', 'five'})." ..
               "should_contain.all_of {'one', 'three'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting table containing all of "one" and "three", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*|%s*%[3%] = \"five\",\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for any_of failures:
        yaml = preamble .. "({'one', 'two', 'five'}).should_contain.any_of {'three', 'seven'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting table containing any of "three" or "seven", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*|%s*%[3%] = \"five\",\n" ..
                                "%s*| %}\n")

    - context while called normally:
      - it succeeds if the element is a table value:
          yaml = preamble .. vals .. ".should_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if listed elements are a permutation of table values:
          yaml = preamble .. vals .. ".should_contain." ..
                 "a_permutation_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if all listed elements are a table value:
          yaml = preamble .. vals .. ".should_contain." ..
                 "all_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if any listed element is a table value:
          yaml = preamble .. vals .. ".should_contain." ..
                 "any_of {'three', 'four', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if the element is a table key:
          yaml = preamble .. keys .. ".should_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if listed elements are a permutation of table keys:
          yaml = preamble .. keys .. ".should_contain." ..
                 "a_permutation_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if all listed elements are a table key:
          yaml = preamble .. keys .. ".should_contain." ..
                 "all_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if any listed element is a table key:
          yaml = preamble .. keys .. ".should_contain." ..
                 "any_of {'three', 'four', 'five'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds with a one-deep match of a table element:
          yaml = preamble .. deep .. ".should_contain { 'subtable 2' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if both tables contain the same elements:
          yaml = preamble .. deep .. ".should_contain." ..
          "a_permutation_of {{'subtable 2'}, {'subtable 1', {'sub-subtable'}}}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if all elements are common to both tables:
          yaml = preamble .. deep .. ".should_contain." ..
          "all_of {{'subtable 2'}, 2}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if there is a common element in both tables:
          yaml = preamble .. deep .. ".should_contain." ..
                 "any_of { 1, 'subtable 2', {3} }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is not a table value:
          yaml = preamble .. vals .. ".should_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if listed elements are not a permutation of table values:
          yaml = preamble .. vals .. ".should_contain." ..
                 "a_permutation_of {'one', 'two', 'nine'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the there are any missing elements:
          yaml = preamble .. vals .. ".should_contain." ..
                 "all_of {'one', 'two', 'nine'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the there are no common elements:
          yaml = preamble .. vals .. ".should_contain." ..
                 "any_of {'three', 'three', 'nine'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the element is not a table key:
          yaml = preamble .. keys .. ".should_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails any element is not also a table key:
          yaml = preamble .. keys .. ".should_contain." ..
                 "a_permutation_of {'one', 'two', 'three'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails any element is not also a table key:
          yaml = preamble .. keys .. ".should_contain." ..
                 "all_of {'one', 'two', 'three'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if no element is also a table key:
          yaml = preamble .. keys .. ".should_contain." ..
                 "any_of {'three', 'three', 'nine'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if either table contains a unique element:
          yaml = preamble .. deep .. ".should_contain." ..
          "a_permutation_of {{'subtable 1'}, {'subtable 2', {'sub-subtable'}}}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if there are any elements missing from the table:
          yaml = preamble .. deep .. ".should_contain." ..
                "all_of { 'one', 'subtable 1', {3} }"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if there are no common elements to both tables:
          yaml = preamble .. deep .. ".should_contain." ..
                "any_of { 'one', 'subtable 1', {3} }"
          expect (run_spec (yaml)).should_contain_output (fail_1)

    - context while called with not_ prefix:
      - it succeeds if the element is not a table value:
          yaml = preamble .. vals .. ".should_not_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if listed elements are not a permutation of table values:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "a_permutation_of {'one', 'two', 'nine'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if all listed elements are not table values:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "all_of {'three', 'three', 'six'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if no listed element is a table value:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "any_of {'three', 'three', 'six'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if the element is not a table key:
          yaml = preamble .. keys .. ".should_not_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds any element is not also a table key:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "a_permutation_of {'one', 'two', 'three'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if all listed elements are not table keys:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "all_of {'three', 'three', 'six'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if no listed element is a table key:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "any_of {'three', 'three', 'six'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds with no one-deep match of a table element:
          yaml = preamble .. deep .. ".should_not_contain { 'subtable 1' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if either table contains a unique element:
          yaml = preamble .. deep .. ".should_not_contain." ..
          "a_permutation_of {{'subtable 1'}, {'subtable 2', {'sub-subtable'}}}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if there are no elements common to both tables:
          yaml = preamble .. deep .. ".should_not_contain." ..
                 "all_of { 'subtable 1' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if there are no elements common to both tables:
          yaml = preamble .. deep .. ".should_not_contain." ..
                 "any_of { 'subtable 1' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is a table value:
          yaml = preamble .. vals .. ".should_not_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if listed elements are a permutation of table values:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "a_permutation_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if all listed elements are table values:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "all_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if any listed element is a table value:
          yaml = preamble .. vals .. ".should_not_contain." ..
                 "any_of {'three', 'four', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the element is a table key:
          yaml = preamble .. keys .. ".should_not_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if listed elements are a permutation of table keys:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "a_permutation_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if all listed elements are table keys:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "all_of {'one', 'two', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if any listed element is a table key:
          yaml = preamble .. keys .. ".should_not_contain." ..
                 "any_of {'three', 'four', 'five'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails with a one-deep match of a table element:
          yaml = preamble .. deep .. ".should_not_contain { 'subtable 2' }"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if both tables contain the same elements:
          yaml = preamble .. deep .. ".should_not_contain." ..
          "a_permutation_of {{'subtable 2'}, {'subtable 1', {'sub-subtable'}}}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if all elements are in both tables:
          yaml = preamble .. deep .. ".should_not_contain." ..
                "all_of {1, { 'subtable 2' }}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if there is a common element in both tables:
          yaml = preamble .. deep .. ".should_not_contain." ..
                "any_of {1, { 'subtable 2' }, {3}}"
          expect (run_spec (yaml)).should_contain_output (fail_1)

  # Any object derived table will do, but since we already have specl.shell
  # loaded, let's use the shell.Process object for these examples.
  - context when receiving an object:
    - before:
        preamble = preamble ..
                   "(hell.Process {1, 'good', 'bad'}).should"

    - it displays expected and actual output for failures: |
        yaml = preamble .. "_contain 'nothing'"
        expect (run_spec (yaml)).
          should_match_output ("expecting Process containing \"nothing\", but got:\n" ..
                                "%s*| %{\n" ..
                                "%s*|%s*errout = \"bad\",\n" ..
                                "%s*|%s*output = \"good\",\n" ..
                                "%s*|%s*status = 1,\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for a_permutation_of failures:
        yaml = preamble ..  "_contain.a_permutation_of {'good', 'bad', 0}"
        expect (run_spec (yaml)).
          should_match_output ('expecting Process containing a permutation of "good", "bad" and 0, but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*errout = \"bad\",\n" ..
                                "%s*|%s*output = \"good\",\n" ..
                                "%s*|%s*status = 1,\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for all_of failures:
        yaml = preamble ..  "_contain.all_of {'1', 'bad'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting Process containing all of "1" and "bad", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*errout = \"bad\",\n" ..
                                "%s*|%s*output = \"good\",\n" ..
                                "%s*|%s*status = 1,\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for any_of failures:
        yaml = preamble ..  "_contain.any_of {'0', 0, 'zero'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting Process containing any of "0", 0 or "zero", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*errout = \"bad\",\n" ..
                                "%s*|%s*output = \"good\",\n" ..
                                "%s*|%s*status = 1,\n" ..
                                "%s*| %}\n")
    - context while called normally:
      - it succeeds if the element is a table value:
          yaml = preamble .. "_contain 'good'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is not a table value:
          yaml = preamble .. "_contain 'marvellous'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if listed elements are a permutation of table values:
          yaml = preamble ..  "_contain.a_permutation_of {'bad', 1, 'good'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if listed elements are not a permutation of table values:
          yaml = preamble ..  "_contain.a_permutation_of {'bad', 1, 'bad'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if all listed elements are a table value:
          yaml = preamble ..  "_contain.all_of {1, 'good', 'bad'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if all listed elements are not a table value:
          yaml = preamble ..  "_contain.all_of {1, 'marvellous', 'bad'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if any listed element is a table value:
          yaml = preamble .. "_contain.any_of {0, 1, 67, 99, 123}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it falis if no listed element is a table value:
          yaml = preamble .. "_contain.any_of {0, -1, -67, -99, -123}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if the element is a table key:
          yaml = preamble .. "_contain 'status'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is not a table key:
          yaml = preamble .. "_contain 'heinous'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if listed elements are a permutation of table keys:
          yaml = preamble ..  "_contain.a_permutation_of {'status', 'output', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if listed elements are not a permutation of table keys:
          yaml = preamble ..  "_contain.a_permutation_of {'status', 'output', 'errout', 1}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if all listed elements are a table key:
          yaml = preamble ..  "_contain.all_of {'status', 'output', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if all listed elements are not a table key:
          yaml = preamble ..  "_contain.all_of {'heinous', 'output', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if any listed element is a table key:
          yaml = preamble .. "_contain.any_of {'static', 'statue', 'status'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it falis if no listed element is a table key:
          yaml = preamble .. "_contain.any_of {'tragus', 'heinous', 'anus'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
    - context while called with not_ prefix:
      - it succeeds if the element is not a table value:
          yaml = preamble .. "_not_contain 'marvellous'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is a table value:
          yaml = preamble .. "_not_contain 'good'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if listed elements are not a permutation of table values:
          yaml = preamble ..  "_not_contain.a_permutation_of {1, 'bad'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if listed elements are a permutation of table values:
          yaml = preamble ..  "_not_contain.a_permutation_of {'bad', 1, 'good'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if all listed elements are not a table value:
          yaml = preamble ..  "_not_contain.all_of {1, 'marvellous', 'bad'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if all listed elements are a table value:
          yaml = preamble ..  "_not_contain.all_of {1, 'good', 'bad'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if no listed element is a table value:
          yaml = preamble .. "_not_contain.any_of {0, -1, -67, -99, -123}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it falis if any listed element is a table value:
          yaml = preamble .. "_not_contain.any_of {0, 1, 67, 99, 123}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if the element is not a table key:
          yaml = preamble .. "_not_contain 'heinous'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is a table key:
          yaml = preamble .. "_not_contain 'status'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if listed elements are not a permutation of table keys:
          yaml = preamble ..  "_not_contain.a_permutation_of {'errout', 'errout', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if listed elements are a permutation of table keys:
          yaml = preamble ..  "_not_contain.a_permutation_of {'errout', 'status', 'output'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if all listed elements are not a table key:
          yaml = preamble ..  "_not_contain.all_of {'heinous', 'output', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if all listed elements are a table key:
          yaml = preamble ..  "_not_contain.all_of {'status', 'output', 'errout'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it succeeds if no listed element is a table key:
          yaml = preamble .. "_not_contain.any_of {'tragus', 'heinous', 'anus'}"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it falis if any listed element is a table key:
          yaml = preamble .. "_not_contain.any_of {'static', 'statue', 'status'}"
          expect (run_spec (yaml)).should_contain_output (fail_1)


- describe match:
  - it diagnoses non-string arguments:
      expect (expect ({"a table"}).should_match {}).
        should_error "string expected"
  - it displays expected and actual output for failures:
      yaml = preamble .. "('no digits').should_match '%d+'"
      expect (run_spec (yaml)).
        should_contain_output 'expecting string matching "%d+", but got "no digits"'
  - it displays all expected and actual output for all_of failures:
      yaml = preamble .. "('no digits').should_match.all_of {'%d+', 'digits'}"
      expect (run_spec (yaml)).
        should_contain_output ('expecting string matching all of "%d+" and "digits", ' ..
                              'but got "no digits"')
  - it displays all expected and actual output for any_of failures:
      yaml = preamble .. "('no digits').should_match.any_of {'%d+', '^digits$'}"
      expect (run_spec (yaml)).
        should_contain_output ('expecting string matching any of "%d+" or "^digits$", ' ..
                              'but got "no digits"')

  - context when called normally:
    - it succeeds if the pattern matches:
        expect ("English Language").should_match "^%w+%s"
    - it succeeds if all listed patterns match:
        expect ("English Language").should_match.all_of {"^%w+", "%s", "g.*g.*g"}
    - it succeeds if any listed pattern matches:
        expect ("English Language").should_match.any_of {"^%w+", "~", "e"}
    - it fails if the pattern does not match:
        yaml = preamble .. "('English Language').should_match '%d+'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if any of the listed patterns match:
        yaml = preamble .. "('English Language').should_match." ..
               "all_of {'^[A-Za-z]*$', 'French Language', '%d+'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if none of the listed patterns match:
        yaml = preamble .. "('English Language').should_match." ..
              "any_of {'^[a-z]*$', 'French Language', '%d+'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds if the pattern does not match:
        expect ("English Language").should_not_match "%d+"
    - it succeeds if none of the listed patterns match:
        expect ("English Language").should_not_match.
          all_of {"^[a-z]*$", "Amarican Language", "%d+"}
    - it succeeds if none of the listed patterns match:
        expect ("English Language").should_not_match.
          any_of {"^[a-z]*$", "Amarican Language", "%d+"}
    - it fails if the pattern matches:
        yaml = preamble .. "('English Language').should_not_match '^%w+%s'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if all of the listed patterns match:
        yaml = preamble .. "('English Language').should_not_match." ..
               "all_of {'^[A-Za-z%s]+$', '^%w+%s', '%D+'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if any of the listed patterns match:
        yaml = preamble .. "('English Language').should_not_match." ..
               "any_of {'^[a-z]+$', '^%w+%s', '%d+'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe error:
  - it displays expected and actual output for failures: |
      yaml = preamble .. "(error 'cheese').should_error 'ham'"
      expect (run_spec (yaml)).
        should_match_output ('expecting an error containing:\n' ..
                             '%s*| ham\n' ..
                             '%s*but got:\n' ..
                             '%s*| .*cheese')
  - it displays all expected and actual output for all_of failures: |
      yaml = preamble .. "(error 'cheese').should_error.all_of {'green eggs', 'ham'}"
      expect (run_spec (yaml)).
        should_match_output ('expecting an error containing all of:\n' ..
                             '%s*| green eggs\n' ..
                             '%s*and:\n' ..
                             '%s*| ham\n' ..
                             '%s*but got:\n' ..
                             '%s*| .*cheese')
  - it displays all expected and actual output for any_of failures: |
      yaml = preamble .. "(error 'cheese').should_error.any_of {'green eggs', 'ham'}"
      expect (run_spec (yaml)).
        should_match_output ('expecting an error containing any of:\n' ..
                             '%s*| green eggs\n' ..
                             '%s*or:\n' ..
                             '%s*| ham\n' ..
                             '%s*but got:\n' ..
                             '%s*| .*cheese')

  - context when called normally:
    - it succeeds if there is an error that contains the message:
        expect (error "error message").should_error "error"
    - it succeeds if there is an error that contains all of the messages:
        expect (error "error message").should_error.
          all_of {"error", "message"}
    - it succeeds if there is an error that contains any of the messages:
        expect (error "error message").should_error.
          any_of {"fail", "error", "bogus"}
    - it succeeds if there is any error with no message argument:
        expect (error "error message").should_error ()
    - it fails if there is an error that does not contain the message:
        yaml = preamble .. "(error 'error message').should_error 'failed'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is an error that does not contain all listed messages:
        yaml = preamble .. "(error 'error message').should_error." ..
               "all_of {'error', 'message', 'exploded'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is an error that does not contain any listed message:
        yaml = preamble .. "(error 'error message').should_error." ..
               "any_of {'failed', 'succeeded', 'exploded'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is no error nor any message argument:
        yaml = preamble .. "('not an error').should_error ()"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is no error:
        yaml = preamble .. "('not an error').should_error 'error'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds if there is no error:
        expect ("not an error").should_not_error "error"
    - it succeeds if there is no error nor any message argument:
        expect ("not an error").should_not_error ()
    - it succeeds if there is an error that does not contain the message:
        expect (error "error message").should_not_error "failed"
    - it succeeds if there is an error that does not contain any listed message:
        expect (error "error message").should_not_error.
          any_of {"failed", "suceeded", "exploded"}
    - it fails if there is any error with no message argument:
        yaml = preamble .. "(error 'error message').should_not_error ()"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is an error that contains the message:
        yaml = preamble .. "(error 'error message').should_not_error 'error'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is an error that contains any listed message:
        yaml = preamble .. "(error 'error message').should_not_error." ..
               "any_of {'fail', 'error', 'bogus'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)

- describe using custom adaptor:
  - before: |
      preamble = [[before: |
        require "spec_helper"
        local matchers = (require "specl.matchers").matchers
        local util     = require "specl.util"

        matchers.equal["the_size_of?"] = function (self, actual, expected, ...)
          util.type_check ("expect", {actual}, {"table"})
          util.type_check ("the_same_size_as", {expected}, {"table"})
          return (#actual == #expected),
            "expecting a table the same size as" ..
            self.format_expect (expected, actual, ...) .. "but got" ..
            self.format_actual (actual, expected, ...)
        end
      ]] .. "\n" .. preamble

  - it diagnoses incompatible expect arguments:
      yaml = preamble .. "(1).should_equal.the_size_of {}"
      expect (run_spec (yaml)).should_contain_error "table expected"
  - it diagnoses incompatible adaptor arguments:
      yaml = preamble .. "({}).should_equal.the_size_of (1)"
      expect (run_spec (yaml)).should_contain_error "table expected"
  - it diagnoses unsupported matchers:
      yaml = preamble .. "({}).should_contain.the_size_of ({})"
      expect (run_spec (yaml)).
        should_contain_error "unknown 'the_size_of' adaptor with 'should_contain'"
  - it displays the expected and actual output for failures:
      yaml = preamble .. "({1, 2, 3}).should_equal.the_size_of {'one'}"
      expect (run_spec (yaml)).
        should_contain_output "expecting a table the same size as "

  - context when called normally:
    - it succeeds if both tables are empty:
        yaml = preamble .. "({}).should_equal.the_size_of {}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it succeeds if both tables are the same size:
        yaml = preamble .. "({1, 2}).should_equal.the_size_of {{3}, 'four'}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it fails if the tables are not the same size:
        yaml = preamble .. "({1, 2}).should_equal.the_size_of {{3, 'four'}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)

  - context when called with not_ prefix:
    - it succeeds if the tables are not the same size:
        yaml = preamble .. "({1, 2}).should_not_equal.the_size_of {{3, 'four'}}"
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it fails if both tables are the same size:
        yaml = preamble .. "({1, 2}).should_not_equal.the_size_of {{3}, 'four'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if both tables are empty:
        yaml = preamble .. "({}).should_not_equal.the_size_of {}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
