before: |
  require "specl.shell"
  require "spec_helper"

  preamble = "before: require 'specl.shell'\nit fails: expect "
  fail_1   = "\n0 passed, 0 pending, and 1 failed"
  pass_all = "\nAll expectations met"

describe matchers:
- before:
    deep = "({{ 'subtable 1', {'sub-subtable'} }, { 'subtable 2' }})"


- describe be matcher:
  - it diagnoses zero alternatives with one_of:
      expect (expect (1).should_be.one_of {}).
        should_error "non-empty table expected"
  - it displays expected and actual output for failures:
      yaml = preamble .. "(1).should_be 'one'"
      expect (run_spec (yaml)).
        should_contain_output 'expecting exactly "one", but got 1'
  - it displays all expected and actual output for one_of failures:
      yaml = preamble .. "(3).should_be.one_of {'five', 2, 1}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting one of "five", 2 or 1, but got 3'
  - it displays the normal format where one_of has only one alternative:
      yaml = preamble .. "(3).should_be.one_of {'five'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting exactly "five", but got 3'

  - context when called normally:
    - it succeeds when comparing identical objects:
        expect (1).should_be (1)
    - it succeeds when object is one of the alternatives:
        expect (2).should_be.one_of {5, 2, 1}
    - it fails when comparing different objects:
        yaml = preamble .. "(1).should_be 'one'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is not one of the alternatives:
        yaml = preamble .. "(3).should_be.one_of {5, 2, 1}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds when comparing different objects:
        expect (1).should_not_be 'one'
    - it succeeds when object is not one of the alternatives:
        expect (3).should_not_be.one_of {5, 2, 1}
    - it fails when comparing identical objects:
        yaml = preamble .. "(1).should_not_be (1)"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails when object is one of the alternatives:
        yaml = preamble .. "(2).should_not_be.one_of {5, 2, 1}"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe equal matcher:
  - it displays expected and actual output for failures:
      yaml = preamble .. "('str').should_equal {'table'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting {1=table}, but got "str"'
  - it displays all expected and actual output for one_of failures:
      yaml = preamble .. "('str').should_equal.one_of {'table', 'number'}"
      expect (run_spec (yaml)).
        should_contain_output 'expecting one of "table" or "number", but got "str"'
  - context when called normally:
    - it succeeds when comparing equal objects:
        expect ({}).should_equal {}
    - it makes a deep comparison of table elements:
        yaml = preamble .. deep .. ".should_equal " .. deep
        expect (run_spec (yaml)).should_contain_output (pass_all)
    - it fails when comparing unequal objects:
        yaml = preamble .. "('str').should_equal {'table'}"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds when comparing unequal objects:
        expect ('str').should_not_equal {'table'}
    - it fails when comparing equal objects:
        yaml = preamble .. "({1, {2}}).should_not_equal {1, {2}}"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe contain matcher:
  - it diagnoses incompatible arguments:
      expect (expect (function () end).should_contain "nothing").
        should_error "string or table expected"

  - context when receiving a string:
    - it displays expected and actual output for failures:
        yaml = preamble .. "('tilde').should_contain '~'"
        expect (run_spec (yaml)).
          should_contain_output 'expecting string containing "~", but got "tilde"'
    - it displays all expected and actual output for one_of failures:
        yaml = preamble .. "('tilde').should_contain.one_of {'~', 'x', 'foo', 9}"
        expect (run_spec (yaml)).
          should_contain_output ('expecting string containing one of "~",' ..
                                 ' "x", "foo" or 9, but got "tilde"')
    - context while called normally:
      - it succeeds if the substring is present:
          expect ("English Language").should_contain "e"
      - it fails if the substring is absent:
          yaml = preamble .. "('English Language').should_contain '~'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
    - context while called with not_ prefix:
      - it succeeds if the substring is absent:
          expect ("English Language").should_not_contain "~"
      - it fails if the substring is present:
          yaml = preamble .. "('English Language').should_not_contain 'e'"
          expect (run_spec (yaml)).should_contain_output (fail_1)

  - context when receiving a table:
    - before:
        vals = "({ 'one', 'two', 'five' })"
        keys = "({ one = true, two = true, five = true })"

    # This is probably too specific and brittle... but I do want to make
    # sure the pretty printing of tables doesn't break with future
    # releases, so let's try and see whether it flies.
    - it displays expected and actual output for failures: |
        yaml = preamble .. "({'one', 'two', 'five'}).should_contain 'three'"
        expect (run_spec (yaml)).
          should_match_output ("expecting table containing \"three\", but got:\n" ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*|%s*%[3%] = \"five\",\n" ..
                                "%s*| %}\n")
    - it displays all expected and actual output for one_of failures:
        yaml = preamble .. "({'one', 'two', 'five'}).should_contain.one_of {'three', 'seven'}"
        expect (run_spec (yaml)).
          should_match_output ('expecting table containing one of "three" or "seven", but got:\n' ..
                                "%s*| %{\n" ..
                                "%s*|%s*%[1%] = \"one\",\n" ..
                                "%s*|%s*%[2%] = \"two\",\n" ..
                                "%s*|%s*%[3%] = \"five\",\n" ..
                                "%s*| %}\n")
    - context while called normally:
      - it succeeds if the element is a table value:
          yaml = preamble .. vals .. ".should_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if the element is a table key:
          yaml = preamble .. keys .. ".should_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - "it succeeds with a one-deep match of a table element":
          yaml = preamble .. deep .. ".should_contain { 'subtable 2' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is not a table value:
          yaml = preamble .. vals .. ".should_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the element is not a table key:
          yaml = preamble .. keys .. ".should_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - "it fails with no one-deep match of a table element":
          yaml = preamble .. deep .. ".should_contain { 'subtable 1' }"
          expect (run_spec (yaml)).should_contain_output (fail_1)
    - context while called with not_ prefix:
      - it succeeds if the element is not a table value:
          yaml = preamble .. vals .. ".should_not_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it succeeds if the element is not a table key:
          yaml = preamble .. keys .. ".should_not_contain 'three'"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - "it succeeds with no one-deep match of a table element":
          yaml = preamble .. deep .. ".should_not_contain { 'subtable 1' }"
          expect (run_spec (yaml)).should_contain_output (pass_all)
      - it fails if the element is a table value:
          yaml = preamble .. vals .. ".should_not_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - it fails if the element is a table key:
          yaml = preamble .. keys .. ".should_not_contain 'five'"
          expect (run_spec (yaml)).should_contain_output (fail_1)
      - "it fails with a one-deep match of a table element":
          yaml = preamble .. deep .. ".should_not_contain { 'subtable 2' }"
          expect (run_spec (yaml)).should_contain_output (fail_1)


- describe match matcher:
  - "it diagnoses non-string arguments":
      expect (expect ({"a table"}).should_match {}).
        should_error "string expected"
  - it displays expected and actual output for failures:
      yaml = preamble .. "('no digits').should_match '%d+'"
      expect (run_spec (yaml)).
        should_contain_output 'expecting string matching "%d+", but got "no digits"'
  - it displays all expected and actual output for one_of failures:
      yaml = preamble .. "('no digits').should_match.one_of {'%d+', '^digits$'}"
      expect (run_spec (yaml)).
        should_contain_output ('expecting string matching one of "%d+" or "^digits$", ' ..
                              'but got "no digits"')

  - context when called normally:
    - it succeeds if the pattern matches:
        expect ("English Language").should_match "^%w+%s"
    - it fails if the pattern does not match:
        yaml = preamble .. "('English Language').should_match '%d+'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds if the pattern does not match:
        expect ("English Language").should_not_match "%d+"
    - it fails if the pattern matches:
        yaml = preamble .. "('English Language').should_not_match '^%w+%s'"
        expect (run_spec (yaml)).should_contain_output (fail_1)


- describe error matcher:
  - it displays expected and actual output for failures: |
      yaml = preamble .. "(error 'cheese').should_error 'ham'"
      expect (run_spec (yaml)).
        should_match_output ('expecting an error containing:\n' ..
                             '%s*| ham\n' ..
                             '%s*but got:\n' ..
                             '%s*| .*: cheese')
  - it displays all expected and actual output for one_of failures: |
      yaml = preamble .. "(error 'cheese').should_error.one_of {'green eggs', 'ham'}"
      expect (run_spec (yaml)).
        should_match_output ('expecting an error containing one of ' ..
                             '"green eggs" or "ham", but got:\n' ..
                             '%s*| .*: cheese')

  - context when called normally:
    - it succeeds if there is an error that contains the message:
        expect (error "error message").should_error "error"
    - it succeeds if there is any error with no message argument:
        expect (error "error message").should_error ()
    - it fails if there is an error that does not contains the message:
        yaml = preamble .. "(error 'error message').should_error 'failed'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is no error nor any message argument:
        yaml = preamble .. "('not an error').should_error ()"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is no error:
        yaml = preamble .. "('not an error').should_error 'error'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
  - context when called with not_ prefix:
    - it succeeds if there is no error:
        expect ("not an error").should_not_error "error"
    - it succeeds if there is no error nor any message argument:
        expect ("not an error").should_not_error ()
    - it succeeds if there is an error that does not contains the message:
        expect (error "error message").should_not_error "failed"
    - it fails if there is any error with no message argument:
        yaml = preamble .. "(error 'error message').should_not_error ()"
        expect (run_spec (yaml)).should_contain_output (fail_1)
    - it fails if there is an error that contains the message:
        yaml = preamble .. "(error 'error message').should_not_error 'error'"
        expect (run_spec (yaml)).should_contain_output (fail_1)
