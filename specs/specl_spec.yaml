before:
  require "spec_helper"

describe specl:
- "describe spec-file format":
  - before: |
      yaml = "describe x:\n- it is pending:"

  - context with empty examples:
    - it exits with zero status:
        expect (run_spec (yaml)).should_exit (0)
    - it complains with no expectations:
        expect (run_spec (yaml)).should_contain_output "No expectations met, "
    - it treats it as a pending example:
        expect (run_spec (yaml)).should_match_output "%*.*1 still pending"

  - context with pending call from example:
    - it exits with zero status:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml)).should_exit (0)
    - it reports pending expectations:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml)).should_match_output "%*.*1 still pending"
    - it reports unexpected pending passes: |
        yaml = yaml .. "\n    pending ()\n    expect (1).should_be (1)"
        expect (run_spec (yaml)).
          should_match_output "%?.*PENDING expectation 1: passed unexpectedly"
    - it uses pending argument for pending passes: |
        yaml = yaml .. " |\n    pending 'issue #23'\n    expect (1).should_be (1)"
        expect (run_spec (yaml)).
          should_match_output "%?.*PENDING expectation 1.*issue #23.*passed unexpectedly"

  - context with Lua error in example:
    - it reports line of error: |
        yaml = yaml .. "\n    print garbage"
        expect (run_spec (yaml)).
          should_contain_error "it is pending:1: '=' expected near 'garbage'"

- describe command line interface:
  - before: |
      yaml = "describe x:\n- it passes: expect (true).should_be (true)"

  - it reads a spec from standard input with no arguments:
      expect (run_spec (yaml)).should_contain_output "All expectations met in "
  - "it reads a spec from standard input for '-' filename argument":
      expect (run_spec {"-"; stdin = yaml}).
        should_contain_output "All expectations met in "
  - it exits with zero status when there are no failing examples:
      expect (run_spec (yaml)).should_exit (0)
  - "it exits with non-zero status when there are failing examples": |
      yaml = "describe x:\n- it fails: expect (1).should_be (0)"
      expect (run_spec (yaml)).should_not_exit (0)
  - it outputs results from a formatter specified on the command line:
      expect (run_spec {"--formatter=tap"; stdin = yaml}).should_contain_output "1..1"

  - context when using a custom formatter:
    - before: |
        -- Write a very basic custom formatter to a temporary file, and add
        -- its location to the lua search path.
        tmpfile = os.tmpname ()
        fdir    = tmpfile:gsub ("/[^/]*$", "", 1)
        fname   = tmpfile:gsub (".*/", "")
        f       = io.open (tmpfile, "w")
        f:write ([[return {
            header  = function () io.write "h" end,
            spec    = function () io.write "s" end,
            expectations = function () io.write "." end,
            footer  = function () io.write "f"; io.flush () end,
          }]])
        f:close ()

    - it formats expectations with the custom formatter:
        command = {
          "--formatter=" .. fname, "-";
          env = { LUA_PATH = fdir .. "/?" },
          stdin = yaml,
        }
        expect (run_spec (command)).should_output "hs.f"
    - "it accepts -f as an equivalent to --formatter":
        command = {
          "-f" .. fname, "-";
          env = { LUA_PATH = fdir .. "/?" },
          stdin = yaml,
        }
        expect (run_spec (command)).should_output "hs.f"

    - after:
        os.remove (tmpfile)
