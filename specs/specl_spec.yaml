describe specl:
- before: |
    function run_spec (yaml, cmd)
      yaml = yaml:gsub ("'", "'\\''")
      cmd  = cmd or ""
      -- if CMD begins with a '-' then only options follow, otherwise
      -- we assume the entire command was passed.
      if cmd == "" or cmd:sub (1, 1) == "-" then
        cmd = "env LUA_PATH='" .. package.path .. "' src/specl --color=no " .. cmd
      end
      return specl.cmdpipe ("printf '%s\\n' '" .. yaml .. "'|" .. cmd)
    end

- "describe spec-file format":
  - before: |
      yaml = "describe x:\n- it is pending:"

  - context with empty examples:
    - it exits with zero status:
        expect (run_spec (yaml).status).should_be (0)
    - it complains with no expectations:
        expect (run_spec (yaml).output).should_contain "No expectations met, "
    - it treats it as a pending example:
        expect (run_spec (yaml).output).should_match "%*.*1 still pending"

  - context with pending call from example:
    - it exits with zero status:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml).status).should_be (0)
    - it reports pending expectations:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml).output).should_match "%*.*1 still pending"
    - it reports unexpected pending passes: |
        yaml = yaml .. "\n    pending ()\n    expect (1).should_be (1)"
        expect (run_spec (yaml).output).
          should_match "%?.*PENDING expectation 1: passed unexpectedly"
    - it uses pending argument for pending passes: |
        yaml = yaml .. " |\n    pending 'issue #23'\n    expect (1).should_be (1)"
        expect (run_spec (yaml).output).
          should_match "%?.*PENDING expectation 1.*issue #23.*passed unexpectedly"

- describe command line interface:
  - before: |
      yaml = "describe x:\n- it passes: expect (true).should_be (true)"

  - it reads a spec from standard input with no arguments:
      expect (run_spec (yaml).output).should_contain "All expectations met in "
  - "it reads a spec from standard input for '-' filename argument":
      expect (run_spec (yaml, "-").output).should_contain "All expectations met in "
  - it exits with zero status when there are no failing examples:
      expect (run_spec (yaml, "src/specl").status).should_be (0)
  - "it exits with non-zero status when there are failing examples": |
      yaml = "describe x:\n- it fails: expect (1).should_be (0)"
      expect (run_spec (yaml, "src/specl").status).should_not_be (0)
  - it outputs results from a formatter specified on the command line:
      expect (run_spec (yaml, "--formatter=tap").output).should_contain "1..1"

  - context when using a custom formatter:
    - before: |
        -- Write a very basic custom formatter to a temporary file, and add
        -- its location to the lua search path.
        tmpfile = os.tmpname ()
        path    = tmpfile:gsub ("/[^/]*$", "", 1)
        name    = tmpfile:gsub (".*/", "")
        f       = io.open (tmpfile, "w")
        f:write ([[return {
            header  = function () io.write "h" end,
            spec    = function () io.write "s" end,
            expectations = function () io.write "." end,
            footer  = function () io.write "f"; io.flush () end,
          }]])
        f:close ()

    - it formats expectations with the custom formatter:
        cmd  = string.format ("env LUA_PATH='%s/?;%s' src/specl --formatter=%s -",
                              path, package.path, name)
        expect (run_spec (yaml, cmd).output).should_contain "hs.f"
    - "it accepts -f as an equivalent to --formatter":
        cmd  = string.format ("env LUA_PATH='%s/?;%s' src/specl -f%s -",
                              path, package.path, name)
        expect (run_spec (yaml, cmd).output).should_contain "hs.f"

    - after:
        os.remove (tmpfile)
