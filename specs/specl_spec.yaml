before:
  require "spec_helper"

describe specl:
- describe spec-file format:
  - before: |
      yaml = "describe x:\n- it is pending:"

  - context with empty examples:
    - it exits with zero status:
        expect (run_spec (yaml)).should_exit (0)
    - it complains with no expectations:
        expect (run_spec (yaml)).should_contain_output "No expectations met, "
    - it treats it as a pending example:
        expect (run_spec (yaml)).should_match_output "%*.*1 still pending"

  - context with pending call from example:
    - it exits with zero status:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml)).should_exit (0)
    - it reports pending expectations:
        yaml = yaml .. " pending ()"
        expect (run_spec (yaml)).should_match_output "%*.*1 still pending"
    - it reports unexpected pending passes: |
        yaml = yaml .. "\n    pending ()\n    expect (1).should_be (1)"
        expect (run_spec (yaml)).
          should_match_output "%?.*PENDING expectation 1: .*passed unexpectedly"
    - it uses pending argument for pending passes: |
        yaml = yaml .. " |\n    pending 'issue #23'\n    expect (1).should_be (1)"
        expect (run_spec (yaml)).
          should_match_output "%?.*PENDING expectation 1.*issue #23.*passed unexpectedly"

  - context with libYAML parse error in spec file:
    - before:
        tmp = Tmpfile (yaml)
    - after:
        tmp:remove ()
    - it diagnoses spurious question mark: |
        tmp:append (" ?\n    garbage")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":2:3: mapping keys are not allowed")
    - it diagnoses spurious braces in plain scalar: |
        tmp:append ("\n    { garbage")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path ..
                                ":4:1: did not find expected ',' or '}'")
    - it diagnoses spurious bracket in plain scalar: |
        tmp:append ("\n    [ garbage")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path ..
                                ":3:7: did not find expected ',' or ']'")
    - it diagnoses missing colon in badly indented line: |
        tmp:append ("\nprint ':'")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3:1: could not find expected ':'")

  - context with LuaMacro parse error in macro expansion:
    - before:
        tmp = Tmpfile (yaml)
    - after:
        tmp:remove ()
    - it diagnoses missing parenthesis in 'expect' call: |
        tmp:append ("\n    expect (fn (x ()).should_be {}")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: parse error near 'expect'")
    - it diagnoses spurious paretheses in 'expect' call: |
        tmp:append (" |" ..
                 "\n    expect (fn (x ()))" ..
                 "\n      ).should_be {}")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":4: unexpected symbol near ')'")
    - it diagnoses missing parentheses before 'expect' call: |
        tmp:append ("\n    garbage ( expect (1).should_be (0) foo")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: ')' expected near 'foo'")
    - it diagnoses spurious parentheses before 'expect' call: |
        tmp:append ("\n    ) expect (1).should_be (0)")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: unexpected symbol near ')'")

  - context with Lua error in first line of example:
    - before:
        tmp = Tmpfile (yaml)
        example = "\n    print garbage"
    - after:
        tmp:remove ()
    - it reports filename and line number for YAML plain style: |
        tmp:append (example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: '=' expected near 'garbage'")
    - it reports filename and line number for YAML literal style: |
        tmp:append (" |" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: '=' expected near 'garbage'")
    - it reports filename and line number for YAML folded style: |
        tmp:append (" >" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: '=' expected near 'garbage'")
    - it reports filename and line number for YAML single-quoted style: |
        tmp:append (" '" .. example .. "'")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: '=' expected near 'garbage'")
    - it reports filename and line number for YAML double-quoted style: |
        tmp:append (' "' .. example .. '"')
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":3: '=' expected near 'garbage'")

  - context with Lua error in multi-line example:
    - before:
        tmp = Tmpfile (yaml)
        example = "\n    x=nil\n    t={}\n    print garbage"
    - after:
        tmp:remove ()
    - it reports filename and line number for YAML plain style: |
        tmp:append (example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":5: '=' expected near 'garbage'")
    - it reports filename and line number for YAML literal style: |
        tmp:append (" |" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":5: '=' expected near 'garbage'")
    - it reports filename and line number for YAML folded style: |
        tmp:append (" >" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":5: '=' expected near 'garbage'")
    - it reports filename and line number for YAML single-quoted style: |
        tmp:append (" '" .. example .. "'")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":5: '=' expected near 'garbage'")
    - it reports filename and line number for YAML double-quoted style: |
        tmp:append (' "' .. example .. '"')
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":5: '=' expected near 'garbage'")

  - context with Lua error in multi-example spec-file:
    - before: |
        tmp = Tmpfile (yaml .. "\n" ..
                       "- it succeeds: |\n" ..
                       "    --\n" ..
                       "    print 'garbage'\n" ..
                       "describe y:\n" ..
                       "- it fails:")
        example = "\n    print garbage"
    - after:
        tmp:remove ()
    - it reports filename and line number for YAML plain style: |
        tmp:append (example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":8: '=' expected near 'garbage'")
    - it reports filename and line number for YAML literal style: |
        tmp:append (" |" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":8: '=' expected near 'garbage'")
    - it reports filename and line number for YAML folded style: |
        tmp:append (" >" .. example)
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":8: '=' expected near 'garbage'")
    - it reports filename and line number for YAML single-quoted style: |
        tmp:append (" '" .. example .. "'")
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":8: '=' expected near 'garbage'")
    - it reports filename and line number for YAML double-quoted style: |
        tmp:append (' "' .. example .. '"')
        expect (run_spec {"--color=no", tmp.path}).
          should_contain_error (tmp.path .. ":8: '=' expected near 'garbage'")

- describe command line interface:
  - before: |
      yaml = "describe x:\n- it passes: expect (true).should_be (true)"

  - it reads a spec from standard input with no arguments:
      expect (run_spec (yaml)).should_contain_output "All expectations met in "
  - it reads a spec from standard input for '-' filename argument:
      expect (run_spec {"-"; stdin = yaml}).
        should_contain_output "All expectations met in "
  - it exits with zero status when there are no failing examples:
      expect (run_spec (yaml)).should_exit (0)
  - it exits with non-zero status when there are failing examples: |
      yaml = "describe x:\n- it fails: expect (1).should_be (0)"
      expect (run_spec (yaml)).should_not_exit (0)
  - it outputs results from a formatter specified on the command line:
      expect (run_spec {"--formatter=tap"; stdin = yaml}).should_contain_output "1..1"

  - context when using a custom formatter:
    - before: |
        -- Write a very basic custom formatter to a temporary file, and add
        -- its location to the lua search path.
        tmp = Tmpfile [[return {
            header  = function () io.write "h" end,
            spec    = function () io.write "s" end,
            expectations = function () io.write "." end,
            footer  = function () io.write "f"; io.flush () end,
          }]]
    - after:
        tmp:remove ()

    - it formats expectations with the custom formatter: |
        command = {
          "--formatter=" .. tmp:basename (), "-";
          env = { LUA_PATH = tmp:dirname () .. "/?" },
          stdin = yaml,
        }
        expect (run_spec (command)).should_output "hs.f"
    - it accepts -f as an equivalent to --formatter:
        command = {
          "-f" .. tmp:basename (), "-";
          env = { LUA_PATH = tmp:dirname () .. "/?" },
          stdin = yaml,
        }
        expect (run_spec (command)).should_output "hs.f"
