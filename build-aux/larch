#!/bin/sh
SH=--[[						# -*- mode: lua; -*-
## Generate a self extracting Lua archive.
##
## This program is distributed under the terms of the license GPLv3
## license reproduced below.

## ====================================================================
## Copyright (c) 2013-2014 Gary V. Vaughan
## Written by Gary V. Vaughan, 2013
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3, or (at your option)
## any later version.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; see the file COPYING.  If not, write to the
## Free Software Foundation, Fifth Floor, 51 Franklin Street, Boston,
## MA 02111-1301, USA.
## ====================================================================

# If LUA is not set, search PATH for something suitable.
test -n "$LUA" || {
  # Check that the supplied binary is executable and returns a compatible
  # Lua version number.
  func_vercheck ()
  {
    test -x "$1" && {
      case `$1 -e 'print (_VERSION)' 2>/dev/null` in
        *"Lua "5\.[12]*) LUA=$1 ;;
      esac
    }
  }

  save_IFS="$IFS"
  LUA=
  for x in lua lua5.2 lua5.1; do
    IFS=:
    for dir in $PATH; do
      IFS="$save_IFS"
      func_vercheck "$dir/$x"
      test -n "$LUA" && break
    done
    IFS="$save_IFS"
    test -n "$LUA" && break
  done
}

# Reexecute using the interpreter suppiled in LUA, or found above.
exec "$LUA" "$0" "$@"
]]SH



--[[ ============== ]]--
--[[ Parse options. ]]--
--[[ ============== ]]--

local usage = "Usage: larch [OPTIONS] FILE...\n"

prog = {
  name = arg[0] and arg[0]:gsub (".*/", "") or "larch",

  opts = {},
}


-- Print an argument processing error message, and return non-zero exit
-- status.
local function opterr (msg)
  io.stderr:write (usage)
  io.stderr:write (prog.name .. ": error: " .. msg .. ".\n")
  io.stderr:write (prog.name .. ": Try '" .. prog.name .. " --help' for help,\n")
  os.exit (2)
end

local function die (msg)
  msg:gsub ("([^\n]+)\n?",
            function ()
              io.stderr:write (prog.name .. ": error: " .. msg.. "\n")
	    end)
  os.exit (1)
end

prog["--help"] = function ()
  print (usage .. [[

Generate a self evaluating Lua archive.

  -e, --evaluate=EXPR  expression to launch archive

Report bugs to http://github.com/gvvaughan/specl/issues.]])
    os.exit (0)
end

prog["--version"] = function ()
  print [[
larch (Specl) 0
Written by Gary V. Vaughan <gary@gnu.org>, 2013

Copyright (C) 2013, Gary V. Vaughan
Larch comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of Larch under the terms of the GNU
General Public License; either version 3, or any later version.
For more information, see <http://www.gnu.org/licenses>]]
  os.exit (0)
end

prog["--evaluate"] = function (arglist, i)
  local opt = arglist[i]
  if i + 1 > #arglist then
    opterr ("option '" .. opt .. "' requires an argument")
  end

  prog.opts.evaluate = arglist[i + 1]
  return i + 1
end

prog["-e"] = prog["--evaluate"]

local nonopts
local i = 0
while i < #arg do
  i = i + 1
  local opt = arg[i]

  -- Collect remaining arguments not nonopts to save back into _G.arg later.
  if type (nonopts) == "table" then
    table.insert (nonopts, opt)

  -- Run prog.option handler.
  elseif opt:sub (1,1) == "-" and type (prog[opt]) == "function" then
    i = prog[opt] (arg, i)

  -- End of option arguments.
  elseif opt == "--" then
    nonopts = {}

  -- Diagnose unknown command line options.
  elseif opt:sub (1, 1) == "-" then
    opterr ("unrecognized option '" .. opt .. "'")

  -- First non-option argument marks the end of options.
  else
    nonopts = { opt }
  end
end

-- put non-option args back into global arg table.
nonopts = nonopts or {}
nonopts[0] = arg[0]
_G.arg = nonopts

if select ("#", ...) < 1 then
  opterr ("only " .. select ("#", ...) .. " arguments provided")
end



--[[ ================= ]]--
--[[ Helper functions. ]]--
--[[ ================= ]]--


function slurp (filename)
  local h, errmsg = io.open (filename)
  if h then
    return h:read "*a"
  end
  error (errmsg)
end



--[[ ======= ]]--
--[[ Output. ]]--
--[[ ======= ]]--


local dirsep, pathsep = package.config:match ("^([^\n]+)\n([^\n]+)\n")

-- A shell-script to embed at the top of an executable lua script
-- between 'SH=--[[' and ']]SH', so that the result can be executed
-- as a shell script that finds a compatible Lua interpreter on the
-- command search PATH.

print [==[
#!/bin/sh
SH=--[[						# -*- mode: lua; -*-
# If LUA is not set, search PATH for something suitable.
test -n "$LUA" || {
  # Check that the supplied binary is executable and returns a compatible
  # Lua version number.
  func_vercheck ()
  {
    test -x "$1" && {
      case `$1 -e 'print (_VERSION)' 2>/dev/null` in
        *"Lua "5\.[12]*) LUA=$1 ;;
      esac
    }
  }

  save_IFS="$IFS"
  LUA=
  for x in lua lua5.2 lua5.1; do
    IFS=:
    for dir in $PATH; do
      IFS="$save_IFS"
      func_vercheck "$dir/$x"
      test -n "$LUA" && break
    done
    IFS="$save_IFS"
    test -n "$LUA" && break
  done
}

# We don't want user environment settings changing the behaviour of this
# script:
LUA_INIT=
export LUA_INIT
LUA_INIT_5_2=
export LUA_INIT_5_2=

# Reexecute using the interpreter suppiled in LUA, or found above.
exec "$LUA" "$0" "$@"
]]SH
]==]


for _, f in ipairs (_G.arg) do
  local module = f:gsub ("^lib" .. dirsep .. "(.*)%.lua$", "%1")
  print ('package.preload["' .. module:gsub (dirsep, ".") ..
         '"] = (function ()')
  print (slurp (f))
  print "end)"
end

print (prog.opts.evaluate)

os.exit (0)
