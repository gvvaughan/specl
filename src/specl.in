#! /bin/sh
A=--[[ exec @LUA@ "$0" "$@"  # -*- mode: lua; -*- ]]A
--
-- Specification testing framework.
--
-- Copyright (c) 2013 Free Software Foundation, Inc.
-- Written by Gary V. Vaughan, 2013
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; see the file COPYING.  If not, write to the
-- Free Software Foundation, Fifth Floor, 51 Franklin Street, Boston,
-- MA 02111-1301, USA.


-- Notify modules that specifications are being checked.
_G._SPEC = true


-- Remove current directory from package search paths.
package.path  = ("@speclpath@;" .. package.path):gsub (
                 ";%./%?.lua;", ";"):gsub (
                 ";%./%?.lua$", "")


local specl  = require "specl"
local util   = require "specl.util"
local yaml   = require "lyaml"


-- Make a shallow copy of the pristine global environment, so that the
-- state of the Specl Lua environment is not exposed to spec files.
local sandbox = {}
for k, v in pairs (_G) do sandbox[k] = v end


-- Called by io.processFiles() to concatenate a comma separated list of
-- specifications in each FILENAME.
local spec = {}
function slurp (filename)
  local s, errmsg = util.slurp ()
  if errmsg ~= nil then
    io.stderr:write (errmsg .. "\n")
    os.exit (1)
  end

  local ok, t = pcall (yaml.load, s)

  -- If loading as YAML didn't work, try again as Lua.
  if not ok then
    local f

    -- Remove leading comment lines, carefully preserving line numbers for
    -- error messages from 'load', and then inject the 'return' keyword at
    -- the start of the first non-blank line.
    s = s:gsub ("^%s*%-%-[^\r\n]+(\r*\n)%s*", "%1"
        ):gsub (",%s*$", ""
        ):gsub ("[^\r\n]", "return %0", 1)
    f, errmsg = loadstring (s, filename)

    if f ~= nil then
      t, errmsg = f ()
    else
      -- To get here, `ok` was false because `yaml.load` failed *and*
      -- loadstring failed too, so `pcall (yaml.load)` saved an error
      -- message in `t`.  And we want to report the YAML load error if
      -- both `yaml.load` and `loadstring` failed:
      errmsg = t
    end
  end
 
  -- Execute the newly loaded function, and save the value returned, or
  -- report any error right away.
  if errmsg ~= nil then
    error (errmsg)
  end

  -- Append to the specification list, which specl will run on completion.
  table.insert (spec, t)
end


opts = util.process_args ()
util.process_files (slurp)

os.exit (specl.run (spec, sandbox))
