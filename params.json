{"name":"Specl","tagline":"Behaviour Driven Development for Lua.","body":"SPECL\r\n=====\r\n\r\n[Behaviour Driven Development][BDD] for [Lua][].\r\n\r\n1. Installation\r\n---------------\r\n\r\nBy far the easiest way to install Specl is with [LuaRocks][]:\r\n\r\n    luarocks install specl\r\n\r\nTo install current git master (for testing):\r\n\r\n    luarocks install https://raw.github.com/gvvaughan/specl/release/specl-git-1.rockspec\r\n\r\nTo install without [LuaRocks][], check out the sources from the\r\n[repository][specl], and then run the following commands: the\r\ndependencies are listed in the dependencies entry of the file\r\n`stdlib-rockspec.lua`. You will also need autoconf and automake.\r\n\r\n    cd lua-stdlib\r\n    autoreconf --force --version --install\r\n    ./configure --prefix=INSTALLATION-ROOT-DIRECTORY\r\n    make all check install\r\n\r\nSee [INSTALL][] for instructions for `configure`.\r\n\r\n\r\n2. Specifications\r\n-----------------\r\n\r\nThe `specl` command verifies that the behaviour of your software meets\r\nthe specifications encoded in one or more _spec-files_. A spec-file is\r\na [YAML][] structured file, laid out as groups of nested plain-English\r\ndescriptions of specifications, with associated snippets of [Lua][]\r\ncode that verify whether the software behaves as described.\r\n\r\nA tiny spec-file outline follows:\r\n\r\n    describe specification file format:\r\n    - it is just a list of examples with descriptions:\r\n        with_Lua_code (\"to verify described behaviours\")\r\n    - it is followed by additional specifications:\r\n        print \"Lua example code demonstrates this specification\"\r\n        print \"on several (indented) lines, if necessary.\"\r\n\r\nThe first significant line of any specification is the plain-English\r\ndescription of the first example group, ending with a `:` (colon).\r\n\r\nUnderneath that are two examples, each starting with `- ` (minus, space)\r\nand separated by a `:` (colon) into a _description_ of some desired\r\nbehaviour, and the associated [Lua][] code to demonstrate it.\r\n\r\nThe descriptions above follow the [RSpec][] convention of using\r\n_describe_ as the first word of a group description, and _it_ as the\r\nfirst word of an example description.  [Specl][] doesn't enforce them,\r\nthey are conventions after all, but `specl` output tends to look much\r\nbetter if you follow them.  There are more conventions regarding the\r\nchoice of first word in a description under various other circumstances,\r\nwhich we'll cover shortly.\r\n\r\nA fuller spec-file will contain several example groups, similar to the\r\none above, each typically followed by dozens of individual examples.\r\nTo easily keep track of what specifications go with what parts of your\r\nimplementation, it's good practice to put all your specs in a\r\nsubdirectory, with one spec named after each file being specified. For\r\nexample, your application might have a `src/stack.lua` class, along\r\nwith a `specs/stack_spec.yaml` file that contains all the matching\r\nspecifications.\r\n\r\nAll of those specifications eventually boil down to lists of behaviour\r\ndescriptions and example code, all indented as prescribed by the\r\n[YAML][] file-format.\r\n\r\n\r\n### 2.1 YAML\r\n\r\n[YAML][] makes for a very readable specification file-format, and allows\r\nembedded [Lua][] code right within the standard, as you saw in the last\r\nsection.  However, there are some rules to follow as you write your\r\nspec-files in order to maintain valid [YAML][] format that [Specl][] can\r\nload correctly.\r\n\r\nIndenting with TAB characters is a syntax error, because the [YAML][]\r\nparser uses indentation columns to infer nesting.  It's easiest just to\r\navoid putting TAB characters in your spec files entirely.\r\n\r\nPunctuation is not allowed in an unquoted [YAML][] string, so you will\r\nneed to force the parser to read the description as a string by\r\nsurrounding it with `\"` (double-quote mark) if you want to put any\r\npunctuation in the description text:\r\n\r\n    - \"it requires double-quote marks, but only when using punctuation\":\r\n\r\nIndentation of the code following an example description must be at\r\nleast one column further in than the first **letter** of the description\r\ntext above, because [YAML][] counts the leading `- ` (minus, space) as\r\npart of the indentation whitespace.\r\n\r\n[Specl][] treats everything following the `:` (colon) as a Lua code:\r\n\r\n    - it concatenates all following indented lines to a single line:\r\n        Stack = require \"stack\"\r\n        stack = Stack {}\r\n\r\nBy default [YAML][] removes indentation and line-breaks from the example\r\ncode following the `:` separator, so that by the time [Lua][] receives\r\nthe code, it's all on a single line.  More often than not, this isn't a\r\nproblem, because the [Lua][] parser is not overly fussy about placement\r\nof line-breaks, but sometimes (to make sure there is a newline to\r\nterminate an embedded comment, for example) you'll need to prevent\r\n[YAML][] from giving [Lua][] everything on a single line. Use the\r\nliteral block marker ` |` (space, pipe) after the `:` separator for\r\nthis:\r\n\r\n    - it does not strip significant whitespace in a literal block: |\r\n        -- A comment on this line, followed by code\r\n        stack = Stack {}\r\n        ...\r\n\r\nYou also have to be careful about commenting within a spec-file. [YAML][]\r\ncomments begin with ` #` (space, hash) and extend to the end of the line.\r\nYou can use these anywhere outside of a Lua code block. [Lua][] comments\r\ndon't work outside of a lua block, and [YAML][] comments don't work\r\ninside a Lua block, so you have to pick the right comment character,\r\ndepending where in the hierarchy it will go.\r\n\r\n### 2.2. Contexts\r\n\r\nYou can further sub-divide your example groups by _context_. In addition\r\nto listing examples in each group, list items can also be contexts,\r\nwhich in turn list more examples of their own:\r\n\r\n    describe a stack:\r\n    - it is empty to start with:\r\n    - context when pushing items:\r\n      - it raises an error if the stack is full:\r\n      - it adds items to the top:\r\n    - context when popping items off the top:\r\n      - it raises an error if the stack is empty:\r\n      - it returns the top item:\r\n      - it removes the popped item:\r\n\r\nBy convention, the context descriptions start with the word \"context\",\r\nbut [Specl][] doesn't enforce that tradition, so you should just try to\r\nwrite a description that makes the output easy to understand (see\r\n[Command Line](#specl-command-line)).\r\n\r\nActually, description naming conventions aside, there is no difference\r\nbetween an example group and a context: Each serves to describe a group\r\nof following examples, or nested contexts.\r\n\r\n[Specl][] doesn't place any restrictions on how deeply you nest your\r\ncontexts: 2 or 3 is very common, though you should seriously consider\r\nsplitting up a spec if you are using more than 4 or 5 levels of nesting\r\nin a single file.\r\n\r\n### 2.3. Examples\r\n\r\nAt the innermost nesting of all those _context_ and _example group_\r\nentries, you will ultimately want to include one or more actual\r\n_examples_. These too are best written with readable names in\r\nplain-English, as shown in the sample from the previous section, but\r\n(unlike contexts) they are followed by the associated example code in\r\n[Lua][], rather than containing more nested contexts.\r\n\r\n    describe a stack:\r\n    - it is empty to start with:\r\n        ...EXAMPLE-LUA-CODE...\r\n    - context when pushing items:\r\n      - it raises an error if the stack is full:\r\n          ...EXAMPLE-LUA-CODE...\r\n    ...\r\n\r\nTraditionally, the example descriptions start with the words \"it\",\r\n\"example\" or \"specify\", but again, [Lua][] really doesn't mind what you\r\ncall them.\r\n\r\n### 2.4. Expectations\r\n\r\nEach of your examples lists a series of expectations that [Specl][] runs\r\nto determine whether the specification for that part of your project is\r\nbeing met. Inside the [Lua][] part of each example, you should write a\r\nsmall block of code that checks that the example being described meets\r\nyour expectations. [Specl][] gives you a new `expect` command to check\r\nthat each example evaluates as it should:\r\n\r\n    - describe a stack:\r\n      - it has no elements when empty:\r\n          stack = Stack {}\r\n          expect (#stack).should_be (0)\r\n\r\nThe call to expect is almost like English: \"Expect size of stack should\r\nbe zero.\"\r\n\r\nBehind the scenes, when you evaluate a Lua expression with expect, it's\r\npassed to a _matcher_ method (`.should_be` in this example), which is\r\nused to check whether that expression matched its expected evaluation.\r\nThere are quite a few matchers already implemented in [Specl], and you\r\ncan easily add new ones if they make your expectations more expressive.\r\n\r\nThe [next section](#specl-matchers) describes the built in matchers in\r\nmore detail.\r\n\r\n### 2.5. Pending Examples\r\n\r\nOften, you'll think of a useful expectation or behaviour that you don't\r\nhave time to implement right now.  Noting it off-line somewhere, or even\r\nadding a commented out example is likely to lead to it being forgotten.\r\nBetter to add it to your spec-file as a _pending example_ while it is\r\nstill on your mind, so that [Specl][] can remind you that it needs\r\nfinishing -- but without contributing a full-blown failing expectation\r\nor specification.\r\n\r\nThe simplest kind of pending example is an example description with no\r\nassociated Lua example code:\r\n\r\n    - it raises an error if the stack is full:\r\n\r\nThe built in formatters will show this as a non-failing unimplemented\r\n(**pending!**) example when the spec-files is run, so you can keep\r\ntrack of specifications you have yet to write.\r\n\r\nAlternatively, if you have written a suitable specification, only to\r\nrealise that you are specifying an unimplemented behaviour, just add\r\nthe call to `pending ()` somewhere near the beginning of the example\r\nto disable following _expectations_, without removing or commenting out\r\nthe `expect` calls:\r\n\r\n    - describe a stack:\r\n      - it has no elements when empty:\r\n          pending ()\r\n          stack = Stack {}\r\n          expect (#stack).should_be (0)\r\n\r\nThis prevents [Specl][] from counting the `expect` result as a failure,\r\nbut crucially also allows [Specl][] to inform you when the expectation\r\nbegins passing to remind you to remove stale `pending ()` calls from\r\nyour specifications.\r\n\r\n    ?.....\r\n \r\n    Summary of pending expectations:\r\n    - a stack has no elements when empty:\r\n      PENDING expectation 1: Passed Unexpectedly!\r\n      You can safely remove the 'pending ()' call from this example\r\n\r\n    All expectations met, but 1 still pending, in 0.00366 seconds.\r\n\r\nSometimes, it's useful to add some metadata to a pending example that\r\nyou want to see in the summary report.  Pass a single string parameter\r\nto the `pending` function call like this:\r\n\r\n    - describe a stack:\r\n      - it cannot remove an element when empty:\r\n          pending \"issue #26\"\r\n          stack = Stack {}\r\n          expect (\"underflow\").should_error (stack.pop ())\r\n\r\nRunning [Specl][] now shows the string in the pending summary report:\r\n\r\n    ?.....\r\n\r\n    Summary of pending expectations:\r\n    - a stack cannot remove an element when empty:\r\n      PENDING expectation 1: issue #26, not yet implemented\r\n\r\n    All expectations met, but 1 still pending, in 0.00332 seconds.\r\n\r\n\r\n<a id=\"specl-matchers\"></a>\r\n3. Matchers\r\n------------\r\n\r\nWhen `expect` looks up a matcher to validate an expectation, the\r\n`should_` part is just syntactic sugar to make the whole line read more\r\nclearly when you say it out loud.  The idea is that the code for the\r\nspecification should be self-documenting, and easily understood by\r\nreading the code itself, rather than having half of the lines in the\r\nspec-file be comments explaining what is going on, and needing to be\r\nkept in sync with the code being described.\r\n\r\nThe matchers themselves are stored by just the root of their name (`be`\r\nin this case).  See [Inverting a Matcher with\r\n`not`](#inverting-a-matcher), for more about why that is.\r\n\r\nThe matchers built in to [Specl][] are listed below.\r\n\r\n### 3.1. `be`\r\n\r\nThis matches only when the result of `expect` is the exact same object\r\nas the matcher argument. For example, [Lua][] interns strings as they\r\nare compiled, so this expectation passes:\r\n\r\n    expect (\"a string\").should_be (\"a string\")\r\n\r\nConversely, [Lua][] constructs a new table object every time it reads\r\none from the source, so this expectation fails:\r\n\r\n    expect ({\"a table\"}).should_be ({\"a table\"})\r\n\r\nWhile the tables look the same, and have the same contents, they are\r\nstill separate and distinct objects.\r\n\r\n### 3.2. `equal`\r\n\r\nTo get around that problem when comparing tables, use the `equal`\r\nmatcher, which does a recursive element by element comparison of the\r\nexpectation. The following expectations all pass:\r\n\r\n    expect ({}).should_equal ({})\r\n    expect ({1, two = \"three\"}).should_equal ({1, two = \"three\"})\r\n    expect ({{1, 2}, {{3}, 4}}).should_equal ({{1, 2}, {{3}, 4}})\r\n\r\n### 3.3. `contain`\r\n\r\nWhen comparing strings, you might not want to write out the entire\r\ncontents of a very long expected result, when you can easily tell with\r\njust some substring whether `expect` has evaluated as specified:\r\n\r\n    expect (backtrace).should_contain (\"table expected\")\r\n\r\nAdditionally, when `expect` evaluates to a table, this matcher will\r\nsucceed if any element or key of that table matches the expectation\r\nstring.  The comparison is done with `equal`, so table elements or\r\nkeys can be of any type.\r\n\r\n    expect ({{1}, {2}, {5}}).should_contain ({5})\r\n\r\nIf `expect` passes anything other than a string or table to this\r\nmatcher, [Specl][] aborts with an error; use `tostring` or similar if\r\nyou need it.\r\n\r\n### 3.4. `match`\r\n\r\nWhen a simple substring search is not appropriate, `match` will compare\r\nthe expectation against a [Lua][] pattern:\r\n\r\n    expect (backtrace).should_match (\"\\nparse.lua: [0-9]+:\")\r\n\r\n### 3.5. `error`\r\n\r\nSpecifications for error conditions are a great idea! And this matcher\r\nchecks both that an `error` was raised and that the subsequent error\r\nmessage contains the supplied substring.\r\n\r\nBecause [Lua][] evaluates the argument to `expect` before `expect`\r\nreceives it, you would have to manually evaluate the expression using\r\n`pcall` to prevent the error it raises from propagating up the stack\r\npast `expect`. The `error` matcher is a syntactic sugar to save writing\r\nthe `pcall`, but in order to do that requires the parameters to be in\r\nthe opposite order of the other matchers.\r\n\r\nNonetheless, the following are broadly equivalent, though one is *much*\r\neasier to understand than the other:\r\n\r\n    expect (\"table expected\").should_error (next, nil)\r\n    expect (function ()\r\n              ok, msg = pcall (next, nil)\r\n              if ok then return false end\r\n              return msg\r\n            end).should_contain (\"table expected\")\r\n\r\n<a id=\"inverting-a-matcher\"></a>\r\n### 3.6. Inverting a matcher with `not`\r\n\r\nOftentimes, in your specification you need to check that an expectation\r\ndoes *not* match a particular outcome, and [Specl][] has you covered\r\nthere too. Rather than implement another set of matchers to do that\r\nthough, you can just insert `not_` right in the matcher method name.\r\n[Specl][] will still call the matcher according to the root name (see\r\n[Matchers](#specl-matchers)), but inverts the result of the comparison\r\nbefore reporting a pass or fail:\r\n\r\n    expect ({}).should_not_be ({})\r\n    expect (tostring (hex)).should_not_contain (\"[g-zG-Z]\")\r\n\r\n\r\n4. Example Environments\r\n-------------------------\r\n\r\nIt's important that every example be evaluated from a clean slate, both\r\nto prevent the side effects of one example affecting the start\r\nconditions of another, and in order to focus on a given example without\r\nworrying what the earlier examples might have done when debugging a\r\nspecification.\r\n\r\n[Specl][] achieves this by initialising a completely new environment in\r\nwhich to execute each example, then tearing it down afterwards to build\r\nanother clean environment for executing the next example, and so on.\r\n\r\n### 4.1. Before and After functions\r\n\r\nTo keep examples as readable and concise as possible, it's best not to\r\nhave too much code in each. For example, it's inefficient to repeat a\r\nfew lines of set up and clean up around each expectation.\r\n\r\nMuch like [RSpec][], [Specl][] supports the use of before and after\r\nfunctions to isolate that repeated code. A `before` is executed prior to\r\nevery example, just after the new environment is initialised, and\r\nconversely `after` is executed immediately after the example has\r\nfinished, just prior to tearing the environment down. Since we don't\r\nneed any fancy long descriptions for `before` and `after` functions,\r\ntheir table keys are just a bare `before` or `after` respectively:\r\n\r\n    ...\r\n    - before: stack = Stack {}\r\n\r\n    - it has no elements when empty:\r\n        expect (#stack).should_equal (0)\r\n    ...\r\n\r\nNote that, unlike normal [Lua][] code, we don't declare everything with\r\n`local` scope, since the environment is reset before each example, so no\r\nstate leaks out.  And, eliding all the redundant `local` keywords makes\r\nfor more concise example code in the specification.\r\n\r\n### 4.2. Grouping Examples\r\n\r\nIf you have used [RSpec][], you'll already know that it supports\r\n`before(:each)` and `before(:all)`, and equivalents for `after`. But\r\nthen goes to some lengths to warn that if you initialise any mutable\r\nstate inside `before(:all)`, then you've provided a way to let one\r\nexample leave side effects that could effect the behaviour of following\r\nexamples.\r\n\r\n[Specl][]'s `before` is equivalent to [RSpec][]'s `before(:each)`,\r\nalthough it has no `before(:all)` analogue (and likewise for `after`).\r\nHowever, [Specl] does support nested contexts, which are mainly useful\r\nfor grouping, but also allow you to write a `before` function outside of\r\na group, where it will behave as if it were a `before(:all)` inside the\r\ngroup:\r\n\r\n    ...\r\n    - describe a Stack:\r\n        - before: |\r\n            -- equivalent to before(:all)\r\n            package.path = \"src/?.lua;\" .. package.path\r\n            Stack = require \"stack\"\r\n\r\n        - context when inspecting the stack:\r\n            - before: |\r\n                -- equivalent to before(:each)\r\n                stack = Stack {}\r\n\r\n            - it has no elements when empty:\r\n            ...\r\n\r\nTricky `before` placement aside, it's always a good idea to organize\r\nlarge spec files in example groups, and the best way to do that is with\r\na nested context (and write the description starting with the word\r\n\"context\" rather than \"describe\" if you are a traditionalist!).\r\n\r\n### 4.3 Environments versus `require`\r\n\r\nThe ideal way to organize your code to make writing the specification\r\nexamples very straight forward is to eliminate (or at least to minimize)\r\nside-effects, so that the behaviour of each API call in every example\r\nis obvious from the parameters and return values alone.\r\n\r\n[Specl][] takes pains to isolate examples from one another; making\r\nsure, among other things, that running a function compiled from a string\r\nchunk in the example will only affect the environment of that example\r\nand not leak out into any following examples.  However, `require`\r\ndefeats these precautions for two reasons:\r\n\r\n  1. Non-local symbols in a required module always refer to `_G` (or\r\n     `_ENV` in Lua 5.2), which, by definition will leak out into\r\n     following examples.  Avoid this by ensuring everything in the\r\n     module is either marked as `local` or returned from the module,\r\n     where the caller can decide whether to corrupt the global\r\n     environment or not.\r\n  2. The returned result of requiring a module is cached, so any code\r\n     executed as a side-effect of the `require` call only takes effect\r\n     on the first call.  Requiring the same module again, even from a\r\n     different example environment, returns the cached result.  Avoid\r\n     this by returning any initial state from the module rather than\r\n     executing arbitrary code on first load.\r\n\r\nWith good module hygiene, you'll probably never even need to be aware of\r\nthe above.  But, if you are writing specifications for an existing\r\nmodule that has side-effects and/or writes in the global environment the\r\nfirst time it is required, then you'll need to construct and order the\r\nrelated code examples carefully not to trip up over either of these two\r\nissues.\r\n\r\nOf course, if you do _anything_ at all to change the global environment\r\n(available as `_G` inside example environments) in code you write or\r\nrun from a code example, then those changes will be visible to, and\r\npossibly impact upon all subsequent tests. Try to avoid doing this if\r\nyou can.\r\n\r\n\r\n5. Formatters\r\n--------------\r\n\r\nAs [Specl][] executes examples and tests the expectations of a\r\nspecification, it can displays its progress using a formatter.\r\n\r\n[Specl][] comes with two formatters already implemented, though you can\r\nwrite your own very easily if the format of the built in formatters\r\ndoesn't suit you.\r\n\r\n### 5.1. Progress Formatter\r\n\r\nThe default formatter simply displays [Specl][]'s progress by writing a\r\nsingle period for every expectation that is met, or an `F` instead if an\r\nexpectation is not met.  Once all the expectations have been evaluated,\r\na one line summary follows:\r\n\r\n    ......\r\n    All expectations met in 0.00233 seconds.\r\n\r\n### 5.2. Report Formatter\r\n\r\nThe other built in formatter writes out the specification descriptions\r\nin an indented list in an easy to read format, followed by a slightly\r\nmore detailed summary.\r\n\r\n    a stack\r\n      is empty to start with\r\n      when pushing items\r\n         raises an error if the stack is full\r\n         adds items to the top\r\n      when popping items off the top\r\n         raises an error if the stack is empty\r\n         returns the top item\r\n         removes the popped item\r\n\r\n    Met 100.00% of 6 expectations.\r\n    6 passed, 0 failed in 0.00250 seconds\r\n\r\nFailed expectations are reported inline, and again in the footer with a\r\nlong header from the associated nested descriptions, making a failing\r\nexample easy to find within a large spec-file.\r\n\r\n### 5.3. Custom Formatters\r\n\r\nA formatter is just a table of functions that [Specl][] can call as it\r\nruns your specifications, so provided you supply the table keys that\r\n[Specl][] is expecting, you can write your own formatters:\r\n\r\n    my_formatter = {\r\n      header       = function () ... end,\r\n      spec         = function (desc_table) ... end,\r\n      expectations = function (status, desc_table) ... end,\r\n      footer       = function (stats, accumulated) ... end,\r\n    }\r\n\r\nThe functions `header` and `footer` are called before any expectations,\r\nand after all expectations, respectively.  The `stats` argument to\r\n`footer` is a table containing:\r\n\r\n    stats = {\r\n      pass      = <PASSED>,\r\n      pend      = <PENDING>,\r\n      fail      = <FAILED>,\r\n      starttime = <CLOCK>,\r\n    }\r\n\r\nYou can use this to print out statistics at the end of the formatted\r\noutput.\r\n\r\nThe `accumulated` argument to `footer` is a string made by concatenating\r\nall the returned strings, if any, from other calls to the formatter API\r\nfunctions.  This is useful, for example, to return failure reports from\r\n`expectations` and then display a summary report from `footer`, like the\r\nbuilt in formatters.\r\n\r\nInstead of accumulating string returns and concatentating them into a\r\nsingle long string to pass back into `footer`, a table of named strings\r\ncan be returned by your `spec` and `expectations` functions, in which\r\ncase the accumulation of those keys is passed back to `footer`.  For\r\nexample, if each call to `expectations` returns a table with these two\r\nkeys:\r\n\r\n    {\r\n      failreport = \"description of failed expectation\\n\",\r\n      pendreport = \"description of pending expectation\\n\",\r\n    }\r\n\r\nThen `footer` will be passed a similar table, but with each entry being\r\nthe accumulation of every non-empty value returned with that key prior\r\nto `footer` being called.  See the built in formatters for more\r\ndetailed examples.\r\n\r\nThe function `spec` is called with a table of each of the descriptions\r\nthat the calling specification or context (the headers with descriptions\r\nthat typically begin with either `describe` or `context`) is nested\r\ninside.\r\n\r\nAnd finally, the function `expectations` is called after each example\r\nhas been run, passing in a tables with the format shown below, with\r\none expectation entry for each `expect` call in that example, along with\r\na similar table of nested descriptions as were passed to `spec`:\r\n\r\n    status = {\r\n      expectations = {\r\n        {\r\n          pending = (nil|true),\r\n          status  = (true|false),\r\n          message = \"error string\",\r\n        },\r\n        ...\r\n      },\r\n      ispending = (nil|true),\r\n    }\r\n\r\nThe outer `ispending` field will be set to `true` if the entire example\r\nis pending - that is, if it has no example code, save perhaps a call to\r\nthe `pending ()` function.\r\n\r\nIf the `pending` field in one of the `expectations` elements is true, then\r\na call was made to `expect ()` from a pending example.  The two are\r\nnecessary so that formatters can diagnose an unexpected `status == true`\r\nin a pending example, among other things.\r\n\r\nThe standard [Specl][] formatters in the `specl/formatters/` sub-\r\ndirectory of your installation show how these functions can be used to\r\ndisplay progress using an output format of your choice.\r\n\r\nSee the next section for details of how to get [Specl][] to load\r\nyour custom formatter.\r\n\r\n\r\n<a id=\"specl-command-line\"></a>\r\n6. Command Line\r\n-----------------\r\n\r\nGiven a spec-file or two, along with the implementation of the code\r\nbeing checked against those specifications, you run [Specl][] inside the\r\nproject directory using the provided `specl` command.\r\n\r\nThe `specl` command expects a list of spec-files to follow, and is\r\nusually called like this:\r\n\r\n    specl specs/*_spec.yaml\r\n\r\nThe output will display results using the default `progress` formatter.\r\nTo use the `report` formatter instead, add the `-freport`\r\noption to the command line above.\r\n\r\nIf you prefer to format the results of your specification examples with\r\na custom formatter, you should make sure your formatter is visible on\r\n`LUA_PATH`, and use the `--formatter=BASENAME` option to load it.\r\n\r\nNote that, for security reasons, Specl removes the current directory\r\nfrom the system search path, so if you want to load a formatter in the\r\ncurrent directory, you will need to explicitly re-enable loading Lua\r\ncode from the current directory:\r\n\r\n    LUA_PATH=`pwd`'/?.lua' specl --formatter=awesome specs/*_spec.yaml\r\n\r\nOtherwise you can load a formatter from the existing `LUA_PATH` by\r\nname, including built in formatters, like this:\r\n\r\n    specl --formatter=tap specs/*_spec.yaml\r\n\r\nPass the `--help` option for help and brief documentation on usage of the\r\nremaining available options.\r\n\r\n\r\n7. Not Yet Implemented\r\n------------------------\r\n\r\nNo support for mocks in the current version.\r\n\r\nThe APIs for adding your own `matchers` are not yet documented.\r\nPlease read the code for now.\r\n\r\n\r\n[bdd]: http://en.wikipedia.org/wiki/Behavior-driven_development\r\n[install]: https://raw.github.com/gvvaughan/specl/master/INSTALL\r\n[lua]: http://www.lua.org\r\n[luarocks]: http://www.luarocks.org\r\n[rspec]: http://github.com/rspec/rspec\r\n[specl]: http://github.com/gvvaughan/specl\r\n[yaml]: http//yaml.org","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}